# Architecture Decision Records (ADR)

이 문서는 데이콘 AI 경진대회 대시보드 프로젝트의 주요 아키텍처 결정을 기록합니다. 각 결정은 "왜 이 기술/방식을 선택했는가?"라는 질문에 대한 답변이며, 나중에 프로젝트를 유지보수하거나 확장할 때 중요한 컨텍스트를 제공합니다.

---

## ADR-001: 프론트엔드 프레임워크로 React 채택

- **날짜:** 2024-07-29
- **상태:** 채택됨

### 컨텍스트 (Context)
- 동적이고 상호작용이 많은 사용자 인터페이스를 구축하기 위해 현대적인 UI 라이브러리가 필요합니다.
- 컴포넌트 기반 아키텍처를 통해 코드의 재사용성과 유지보수성을 높여야 합니다.

### 결정 (Decision)
- 프론트엔드 개발을 위해 **React**를 사용하기로 결정했습니다.

### 근거 (Rationale)
- **컴포넌트 기반 아키텍처:** UI를 독립적이고 재사용 가능한 컴포넌트로 분리하여 개발할 수 있어 생산성과 유지보수성이 향상됩니다.
- **강력한 생태계:** 방대한 라이브러리와 커뮤니티 지원을 통해 필요한 기능을 쉽게 확장하고 문제를 해결할 수 있습니다.
- **Virtual DOM:** 효율적인 UI 업데이트를 통해 높은 성능을 보장합니다.
- **초기 프로젝트 설정:** 프로젝트가 `index.tsx`를 사용하는 React 기반으로 초기 설정되어 있어, 일관성을 유지하는 것이 합리적입니다.

### 고려된 대안 (Alternatives Considered)
- **Vue.js:** React와 유사한 컴포넌트 모델을 가졌지만, React가 더 큰 생태계와 국내 개발 커뮤니티를 보유하고 있습니다.
- **Svelte:** 컴파일 시점에 최적화된 바닐라 자바스크립트로 변환되어 런타임 오버헤드가 적지만, 팀의 기존 경험이 React에 더 집중되어 있습니다.
- **Vanilla JavaScript:** 외부 라이브러리 없이 구현할 수 있지만, 상태 관리와 컴포넌트화에 많은 보일러플레이트 코드가 필요하여 복잡성이 증가합니다.

---

## ADR-002: 스타일링 전략으로 Tailwind CSS와 Custom CSS 혼용

- **날짜:** 2024-07-29
- **상태:** 채택됨

### 컨텍스트 (Context)
- 애플리케이션은 '글래스모피즘', '뉴로모피즘', '웹툰'이라는 세 가지 독특하고 복잡한 시각적 테마를 지원해야 합니다.
- 유연하고 확장 가능한 스타일링 시스템이 필요합니다.

### 결정 (Decision)
- **Tailwind CSS**를 유틸리티-우선(utility-first) 스타일링의 기반으로 사용하고, 복잡한 애니메이션, 전역 스타일, 테마별 세부 제어를 위해 **`index.html` 내 `<style>` 태그에 Custom CSS**를 혼용하기로 결정했습니다.

### 근거 (Rationale)
- **Tailwind CSS:** HTML/JSX를 떠나지 않고 빠르게 컴포넌트 스타일을 지정할 수 있어 개발 속도가 빠릅니다. 디자인 시스템의 일관성을 유지하기 용이합니다.
- **Custom CSS:** 다음과 같은 경우에 더 적합합니다.
    - **복잡한 애니메이션:** `@keyframes`를 사용한 정교한 애니메이션 정의.
    - **전역 스타일:** `body` 태그 등 전역적인 스타일 적용.
    - **테마 관리:** `.theme-glass`, `.theme-webtoon`과 같은 클래스 셀렉터를 통해 테마별 스타일을 그룹화하고 오버라이드하는 것이 JavaScript에서 수많은 유틸리티 클래스를 동적으로 제어하는 것보다 깔끔하고 관리하기 쉽습니다.

### 고려된 대안 (Alternatives Considered)
- **CSS-in-JS (예: Styled Components, Emotion):** 컴포넌트 범위의 스타일과 props 기반의 동적 스타일링이 가능하지만, 런타임 오버헤드가 발생하며, 우리가 사용한 단순한 클래스 기반 테마 전환 방식에 비해 설정이 복잡할 수 있습니다.
- **UI 컴포넌트 라이브러리 (예: Material-UI, Ant Design):** 사전 제작된 컴포넌트를 제공하지만, 이번 프로젝트처럼 매우 독특하고 커스텀한 테마를 구현할 때는 제약이 많고 스타일을 오버라이드하기 번거롭습니다.

---

## ADR-003: 클라이언트 사이드에서 직접 Gemini API 호출

- **날짜:** 2024-07-29
- **상태:** 채택됨

### 컨텍스트 (Context)
- 'AI 확장 검색', 'AI 추천 카드', '동적 배너' 등 생성형 AI 모델을 활용하는 다수의 기능이 필요합니다.
- API 키는 `process.env.API_KEY` 환경 변수를 통해서만 접근해야 한다는 엄격한 요구사항이 있습니다.

### 결정 (Decision)
- 클라이언트(브라우저)에서 직접 **Google Gemini API**를 호출하기로 결정했습니다.

### 근거 (Rationale)
- **단순성:** API 호출을 중계할 별도의 백엔드 서버가 필요 없어 아키텍처가 단순해집니다. 이 프로젝트는 단일 페이지 애플리케이션(SPA)이므로 이 방식이 효율적입니다.
- **성능:** 중계 서버를 거치지 않고 직접 API를 호출하므로 지연 시간(latency)을 줄일 수 있습니다.
- **요구사항 준수:** API 키를 `process.env.API_KEY`에서만 가져와야 한다는 프로젝트의 제약 조건을 완벽하게 준수합니다. (빌드 시점에 키가 코드에 포함됨)

### 고려된 대안 (Alternatives Considered)
- **백엔드 프록시 서버 구축:** API 키를 안전하게 관리하기 위해 Node.js 등으로 중계 서버를 만드는 방식입니다. 일반적인 프로덕션 환경에서는 이 방식이 더 안전하지만, 이 프로젝트의 제약 조건 하에서는 불필요한 아키텍처 복잡성(서버 유지보수, 배포, CORS 처리 등)을 야기합니다.

---

## ADR-004: React Hooks를 사용한 상태 관리

- **날짜:** 2024-07-30
- **상태:** 채택됨

### 컨텍스트 (Context)
- 외부 API에서 데이터를 가져오고, 여러 콘텐츠 뷰(대회, 학습, 코드, 로드맵)에 대한 필터, 정렬, 테마 등 애플리케이션의 상태를 관리해야 합니다.
- 상태가 복잡해졌지만, 애플리케이션의 모든 주요 로직은 `App.tsx`라는 단일 컴포넌트에 집중되어 있습니다.

### 결정 (Decision)
- **React에 내장된 Hooks (`useState`, `useEffect`, `useCallback`, `useMemo` 등)**를 사용하여 모든 상태 관리 로직을 처리하기로 결정했습니다.

### 근거 (Rationale)
- **충분성 및 단순성:** 현재 애플리케이션의 규모와 구조(단일 최상위 컴포넌트)에서는 React 내장 Hooks만으로도 충분히 상태를 관리할 수 있으며, 불필요한 외부 라이브러리 의존성과 보일러플레이트를 피할 수 있습니다.
- **중앙 집중화된 로직:** 모든 상태 관련 로직이 `App.tsx`에 중앙 집중화되어 있어, props drilling이 거의 없고 상태 흐름을 파악하기 용이합니다.
- **성능 최적화:** `useMemo`와 `useCallback`을 사용하여 복잡한 필터링/정렬 연산을 메모이제이션하고, 불필요한 리렌더링을 방지하여 성능을 최적화하고 있습니다.

### 고려된 대안 (Alternatives Considered)
- **Redux / Redux Toolkit:** 강력한 전역 상태 관리 라이브러리지만, 현재 구조에서는 이 프로젝트의 상태 관리 요구사항에 비해 과도한(overkill) 기능과 복잡성을 도입하게 됩니다.
- **Zustand / Jotai:** 경량 상태 관리 라이브러리. 좋은 대안이지만, `App.tsx`에서 `useState`로 전역 상태처럼 관리하는 현 방식이 프로젝트 규모에 더 적합하고 간단합니다.

---

## ADR-005: API 호출과 정적 데이터 폴백(Fallback) 전략 채택

- **날짜:** 2024-07-30
- **상태:** 채택됨

### 컨텍스트 (Context)
- 애플리케이션은 외부 Dacon API에 의존하여 최신 대회 및 학습 콘텐츠 데이터를 가져옵니다.
- 이 API는 불안정하거나, 실패하거나, 응답이 없을 수 있습니다.
- 또한 '데이터 다운로드 가능 대회'처럼 API에서 제공하지 않는 특정 큐레이션된 목록이 필요합니다.

### 결정 (Decision)
- 데이터 페칭 시, **먼저 라이브 API를 호출하고, 호출에 실패하거나 유효한 데이터가 없을 경우 사전에 번들링된 정적 JSON 데이터로 자동으로 폴백(fallback)하는 전략**을 채택하기로 결정했습니다.

### 근거 (Rationale)
- **애플리케이션 안정성 (Resilience):** API 장애 발생 시에도 애플리케이션이 핵심 기능을 계속 제공할 수 있어 사용자 경험을 저해하지 않습니다.
- **데이터 완전성 (Completeness):** API에서 제공하지 않는 레거시 데이터나 특정 목적(예: 데이터 다운로드 링크가 있는 대회 목록, '예정 대회' 카드)을 위해 큐레이션된 데이터를 정적 파일로 포함하여 제공할 수 있습니다.
- **구현의 단순성:** 복잡한 클라이언트 사이드 캐싱이나 서비스 워커 로직 없이, `try-catch` 블록과 조건문만으로 간단하게 구현할 수 있습니다. 이는 프로젝트의 전반적인 복잡성을 낮게 유지하는 데 기여합니다.

### 고려된 대안 (Alternatives Considered)
- **API 전용 접근:** API 호출 실패 시 에러 메시지만 표시하는 방식. 이는 API가 다운될 경우 애플리케이션이 완전히 무용지물이 되는 결과를 초래합니다.
- **서비스 워커를 이용한 캐싱:** 더 강력한 오프라인 지원과 캐싱 전략을 제공하지만, 구현 및 유지보수 복잡성이 크게 증가하여 현재 프로젝트의 범위에 비해 과도합니다.
- **로컬 스토리지 캐싱:** API 응답을 로컬 스토리지에 캐싱하는 방식. 데이터의 최신성을 보장하기 위한 추가적인 로직(예: 만료 시간 관리)이 필요하며, 사용자의 첫 방문 시에는 폴백 전략이 여전히 필요합니다.